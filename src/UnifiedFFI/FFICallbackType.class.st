"
I'm a FFICallback type. 
I can handle callback type parameters.

What I actually do is to pass the content of #thunk instVar of the objectClass as parameter. 
Thunk needs to be a callback thunk (and then an ExternalAddress).
The C side of a callback is void* (because is a pointer to a function)
"
Class {
	#name : #FFICallbackType,
	#superclass : #FFIExternalObjectType,
	#category : #'UnifiedFFI-Types'
}

{ #category : #accessing }
FFICallbackType >> instanceVariableName [
	^ #thunk
]

{ #category : #'emitting code' }
FFICallbackType >> offsetReadFieldAt: offsetVariableName [
	^ String streamContents: [ :stream | 
		stream << '^' << self objectClass name << ' forAddress: ((handle pointerAt: ' << offsetVariableName asString << ') asInteger)' ]
]

{ #category : #'emitting code' }
FFICallbackType >> offsetWriteFieldAt: offsetVariableName with: valueName [
	| newLine tab |
	newLine := String newLine.
	tab := String tab.
	^ String streamContents: [ :stream | 
		stream 
			<< 'handle ' << newLine 
			<< tab << tab << 'pointerAt: ' << offsetVariableName << newLine 
			<< tab << tab << 'put: (anObject ' << newLine 
			<< tab << tab << tab << 'ifNotNil: [ ExternalAddress fromAddress: anObject thunk address ]' << newLine
			<< tab << tab << tab << 'ifNil: [ ExternalAddress null ])' ]
]

{ #category : #'emitting code' }
FFICallbackType >> readFieldAt: byteOffset [
	^ String streamContents: [ :stream | 
		stream << '^' << self objectClass name << ' forAddress: ((handle pointerAt: ' << byteOffset asString << ') asInteger)' ]
]

{ #category : #'emitting code' }
FFICallbackType >> writeFieldAt: byteOffset with: valueName [
	^ String streamContents: [ :stream | 
		stream << 'handle pointerAt: ' << byteOffset asString << ' put: (ExternalAddress fromAddress: anObject thunk address)' ]
]
